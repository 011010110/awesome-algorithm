最近正在面试，最开始因为没有这样准备过，所以总是被问的一脸懵逼，相信很多人跟我有过一样的经历，时间长就是忘了嘛，对不对，无奈。
怒🔥一上来打算好好整理下，面试前过一遍，岂不是美滋滋！

# Java基础
## 1. 面向对象和面向过程的区别
- 面向过程强调动作，物体本身只是一个属性或者参数，具体为一件事该怎么做。   ```吃.(狗，屎)  吃.(🐶, 💩)```
    - 优点：性能比面向对象高，因为类调用时需要实例化，比较消耗资源;较底层的东西比如单片机、嵌入式开发、Linux/Unix等一般采用面向过程开发，性能是最重要的因素。
    - 缺点：没有面向对象易维护、易复用、易扩展
- 面向对象强调object，动作只是一个函数，具体为一件事该让谁去做。         ```狗.吃(屎)  🐶.吃(💩)```
    - 优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护
    - 缺点：性能比面向过程低

## 2. Java的四个基本特性（抽象、封装、继承，多态）
- ***抽象***：就是把现实生活中的某一类东西提取出来，用类或者接口表示。抽象包括两个方面：一个是数据抽象，一个是过程抽象。数据抽象也就是对象的属性。过程抽象是对象的行为特征。
- ***封装***：把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行封装隐藏。封装分为属性的封装和方法的封装。
    - 1. 安全
    - 2. 将内外隔离
    - 3. 便于使用
    - 4. 提供重复性，具有模块化
- ***继承***：父类抽取多类事物的共性，不同子类继承父类根据自身条件不同对父类方法进行重载或重写。
- ***多态***：从某种角度上来说，封装和继承就是为了多态而做准备的。多态采用的方法是动态绑定（dynamic binding），是指在执行期间判断所引用对象的实际类型，根据其实际的类型调用其相应的方法。多态必须同时满足三个条件：
    - 1. 要有继承
    - 2. 要有重写
    - 3. 父类引用指向子类对象

    多态其实就是父类提供一个接口，基于同一个接口，使用不同的实例就可以使用不同的功能
    ```java
    Father f = new Son();
    ```
## 3. 重载和重写的区别
- 重载：发生在同一个类中，方法名必须相同，参数类型、个数或者顺序不同，方法返回值和访问修饰符可以不同，发生在编译时。
- 重写：发生在父子类中，方法名、参数列表必须相同，返回值小于等于父类，抛出的异常小于等于父类，访问修饰符大于等于父类；如果父类方法访问修饰符为private则子类中就不是重写。

# 4. 构造器Constructor是否可被override
构造器不能被重写，不能用static修饰构造器，只能用public，private，protected这三个权限修饰符，且不能有返回语句。
1. 构造器与类同名 （构造函数，initilize 函数）
2. 每个类可以有一个以上的构造器
3. 构造器可以有0个，1个以及多个参数 （无参构造函数，有参构造函数）
4. 构造器没有返回值（与void明显不同，构造器不会返回任何东西，你别无选择。）
5. 构造器总是伴随着new操作符一起调用
6. 构造器不可被继承

# 5. 访问控制符public,protected,private,以及默认的区别

|                    |   任意地方   | 同一个包 |  子类  | 同一个类 |
| :----------------: | :------: | :--: | :--: | :--: |
|  Public (接口访问权限)   |    🌈    |  🌈  |  🌈  |  🌈  |
| Protected (继承访问权限) | 🌈(需要继承) |  🌈  |  🌈  |  🌈  |
|  Default (包访问权限)   |          |  🌈  |  🌈  |  🌈  |
|  Private (类访问权限)   |          |      |      |  🌈  |


- public（接口访问权限）：任何地方都能访问；
- protected（继承访问权限）: 介于public 和 private 之间的一种访问修饰符，一般称之为“保护形”。被其修饰的类、属性以及方法只能被类本身的方法及子类访问，即使子类在不同的包中也可以访问。在同包内的类及包外的子类能访问；
- default（包访问权限）：即不加任何访问修饰符，通常称为“默认访问模式“。该模式下，只允许在同一个包中进行访问。 
- private（类访问权限）: 只有在本类中才能访问；
（只限在Java语言中……）

# 6. 是否可以继承String类
String类是final类故不可以继承，一切由final修饰过的都不能继承。

# 7. String和StringBuffer、StringBuilder的区别
- 可变性

String类中使用字符数组保存字符串，private final char value[]，所以string对象是不可变的。
StringBuilder与StringBuffer都继承自AbstractStringBuilder类，在AbstractStringBuilder中也是使用字符数组保存字符串，char[] value，
这两种对象都是可变的。
- 线程安全性

String中的对象是不可变的，也就可以理解为常量，线程安全。
AbstractStringBuilder是StringBuilder与StringBuffer的公共父类，定义了一些字符串的基本操作，如expandCapacity、append、insert、indexOf等公共方法。
StringBuffer对方法加了同步锁或者对调用的方法加了同步锁，所以是***线程安全***的。
StringBuilder并没有对方法进行加同步锁，所以是***非线程安全***的。
- 性能

每次对 String 类型进行改变的时候，都会生成一个新的String 对象，然后将指针指向新的String 对象。StringBuffer每次都会对
StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用StirngBuilder 相比使用
StringBuffer 仅能获得10%~15% 左右的性能提升，但却要冒多线程不安全的风险。
综合速度```String < StringBuffer < StirngBuilder```
