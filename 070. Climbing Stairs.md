### 70. Climbing Stairs


题目:
<https://leetcode.com/problems/climbing-stairs/>


难度:
Easy

思路：

Fibonacci 的DP版本

对于DP的不同理解造成不同的写法	
Memoization will usually add on your time-complexity to your space-complexity (e.g. with tabulation you have more liberty to throw away calculations, like using tabulation with Fib lets you use O(1) space, but memoization with Fib uses O(N) stack space).
详看[Dynamic programming and memoization: bottom-up vs top-down approaches](https://stackoverflow.com/questions/6164629/dynamic-programming-and-memoization-bottom-up-vs-top-down-approaches)
-  top-down(memorize)

```
memo = {}
def fib(n):
	if n in memo: return memo[n]
	else:
		if n <= 2 : f = 1
		else: f = fib(n-1) + fib(n-2)
		memo[n] = f
		return f 
```
- bottom up(tabulation)

```
fib = {}
for k in range(n):
	if k <= 2 : f = 1
	else: f = fib[k-1] + fib[k-2]
	fib[k] = f
return fib[n]
```


这里memo用dict，用array也一样。当然用bottom up还有一点，可以只存每次最后两个数，可以save space.，这样就只用到constant space.

AC 代码

```python
class Solution(object):
    def climbStairs(self, n):
        """
        :type n: int
        :rtype: int
        """
        memo = {}
        memo[2] = 2
        memo[1] = 1

        for i in range(3,n+1):
        	f = memo[i-1] + memo[i-2]     # 这里用一个临时变量f来存储值，所以不用像memorize方法一样一直保存着
        	memo[i] = f                   # 因此永远只存每次最后两个数，save space
        return memo[n]
```



